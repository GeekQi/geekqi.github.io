{"meta":{"title":"YangQi's Coding Time","subtitle":null,"description":null,"author":"YangQi","url":"https://geekqi.github.io"},"pages":[{"title":"about","date":"2017-10-09T03:17:47.000Z","updated":"2017-05-19T08:55:52.000Z","comments":false,"path":"about/index.html","permalink":"https://geekqi.github.io/about/index.html","excerpt":"","text":""},{"title":"link","date":"2017-10-09T03:17:47.000Z","updated":"2017-05-19T08:54:04.000Z","comments":false,"path":"link/index.html","permalink":"https://geekqi.github.io/link/index.html","excerpt":"","text":""},{"title":"search","date":"2017-10-09T03:17:47.000Z","updated":"2017-05-19T08:53:37.000Z","comments":false,"path":"search/index.html","permalink":"https://geekqi.github.io/search/index.html","excerpt":"","text":""},{"title":"project","date":"2017-10-09T03:17:47.000Z","updated":"2017-05-19T08:53:47.000Z","comments":false,"path":"project/index.html","permalink":"https://geekqi.github.io/project/index.html","excerpt":"","text":""},{"title":"category","date":"2017-10-09T03:17:47.000Z","updated":"2017-05-19T08:54:14.000Z","comments":false,"path":"category/index.html","permalink":"https://geekqi.github.io/category/index.html","excerpt":"","text":""},{"title":"tag","date":"2017-10-09T03:17:47.000Z","updated":"2017-05-19T08:53:56.000Z","comments":false,"path":"tag/index.html","permalink":"https://geekqi.github.io/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"baidu_verify_m4cIjhcLJ9","date":"2017-06-22T11:49:45.000Z","updated":"2017-06-22T11:49:45.000Z","comments":true,"path":"2017/06/22/baidu_verify_m4cIjhcLJ9/","link":"","permalink":"https://geekqi.github.io/2017/06/22/baidu_verify_m4cIjhcLJ9/","excerpt":"","text":"m4cIjhcLJ9","categories":[],"tags":[]},{"title":"「进攻」是最好的「防御」","slug":"进攻是最好的防御","date":"2017-06-07T16:07:28.000Z","updated":"2017-06-07T16:07:28.000Z","comments":true,"path":"2017/06/08/进攻是最好的防御/","link":"","permalink":"https://geekqi.github.io/2017/06/08/进攻是最好的防御/","excerpt":"","text":"注：为个人学习总结需要，如有侵权，请您指出。[持续更新， 如有错误，请您指出] ​ 「进攻」是最好的「防御」​ 不可胜，守；可胜，攻也； A.学术论文／研究项目／工程项目／创业项目 python基础 - get！ sql基础 - get! ### 关于基础知识：如下： 1.刷题 目的分析：基础知识的掌握牢固， 「 基础熟练决定你的灵活性！」 解决办法：大量做题，「 不比别人熟练，必败」 可能方式：纽克、柒越 2.简历 目的分析：让人接受你的努力， 「 被认可，被膜拜，这是主流！」 时间节点：6月底 3.经验 目的分析：系统性质的项目过程， 「 灵活的经验才能被主流朝拜！」 解决办法：实战项目、开源项目， 「 片段化不系统，机会抓不住」 可能方式：豪洞悉、艾科科、工种薅、英语","categories":[{"name":"主要目标判断","slug":"主要目标判断","permalink":"https://geekqi.github.io/分类/主要目标判断/"}],"tags":[]},{"title":"核心技能get！令人发指！","slug":"核心技能get！令人发指！","date":"2017-05-31T10:12:01.000Z","updated":"2017-05-31T10:12:01.000Z","comments":true,"path":"2017/05/31/核心技能get！令人发指！/","link":"","permalink":"https://geekqi.github.io/2017/05/31/核心技能get！令人发指！/","excerpt":"","text":"注：为个人学习总结需要，如有侵权，请您指出。[持续更新， 如有错误，请您指出] 核心技能get！令人发指！ A+.机器学习／自然语言处理 10.用数据解读《欢乐颂2》&amp;version=12020710&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=CyO%2BvJvJJKh3oZAY0Bnvz0B0u3XoCbw7V1Q%2F21AyX72v3L%2FFG2%2Fk8SV%2FYJVIgKz7) 9. ​ A+.工程项目 10. 9. A++.“创业”项目思路 10. 9. A.行业游戏规则 10. 9. 关于基础知识：如下 1.刷题 目的分析：基础知识的掌握牢固， 「 基础熟练决定你的灵活性！」 解决办法：大量做题，「 不比别人熟练，必败」 可能方式：纽克、柒越 2.简历 目的分析：让人接受你的努力， 「 被认可，被膜拜，这是主流！」 时间节点：6月底 3.经验 目的分析：系统性质的项目过程， 「 灵活的经验才能被主流朝拜！」 解决办法：实战项目、开源项目， 「 片段化不系统，机会抓不住」 可能方式：豪洞悉、艾科科、工种薅、英语","categories":[{"name":"核心技能get！","slug":"核心技能get！","permalink":"https://geekqi.github.io/分类/核心技能get！/"}],"tags":[]},{"title":"python记忆力曲线","slug":"python记忆力曲线","date":"2017-05-31T01:22:45.000Z","updated":"2017-05-31T01:22:45.000Z","comments":true,"path":"2017/05/31/python记忆力曲线/","link":"","permalink":"https://geekqi.github.io/2017/05/31/python记忆力曲线/","excerpt":"","text":"注：为个人学习总结需要，如有侵权，请您指出。[持续更新， 如有错误，请您指出] A.python基础，看看哈1.python是什么？语言：解释型、交互性、面向对象 2.python中文编码怎么搞？默认：ASCII。 需要：开头加入：# -*- coding:UTF-8 -*- 3.python 标识符怎么写？包括：字母、数字[不可开头]、下划线[单下划线表示不能直接访问类属性、需要类接口访问，不能from XXX import * 导入／双下滑线代表类的私有成员／双下划线开头结尾代表特殊方法专用(_init\\_()代表类的构造函数)] 4.python引号用几个？‘ ’／’‘ “／” “ ” “ ” “ 都行 5.python 注释用什么?#, ‘ ’ ‘ ‘ ’ ‘ ，” “ ” ” “ ” 多行 6.python等待用户输入?1raw_input(\"\\n\\nPlease input something:.\") 7.python多变量赋值？1a, b, c = 1, 2, \"john\" 8.python 元组能像列表一样更新么？123456#!/usr/bin/python# -*- coding: UTF-8 -*-tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )list = [ 'runoob', 786 , 2.23, 'john', 70.2 ]tuple[2] = 1000 # 元组中是非法应用list[2] = 1000 # 列表中是合法应用 9.python字典创建、赋值、取值、取键，好写不？1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*-dict = &#123;&#125;dict['one'] = \"This is one\"dict[2] = \"This is two\"tinydict = &#123;'name': 'john','code':6734, 'dept': 'sales'&#125;print dict['one'] # 输出键为'one' 的值print dict[2] # 输出键为 2 的值print tinydict # 输出完整的字典print tinydict.keys() # 输出所有键print tinydict.values() # 输出所有值 输出结果： 12345This is oneThis is two&#123;'dept': 'sales', 'code': 6734, 'name': 'john'&#125;['dept', 'code', 'name']['sales', 6734, 'john'] 10.python 类型转换怎么搞？ 函数 功能描述 str(x) 将对象 x 转换为字符串 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个序列 (key,value)元组。 ord(x) 将一个字符转换为它的整数值 chr(x) 将一个整数转换为一个字符 11.python的数据类型怎么查看？123&gt;&gt;&gt; n=1&gt;&gt;&gt; type(n)&lt;type 'int'&gt; 或者 123a = 111isinstance(a, int)True 12.python的位运算符怎么写呢？1234567a = 0011 1100b = 0000 1101-----------------a&amp;b = 0000 1100 与a|b = 0011 1101 或a^b = 0011 0001 异或~a = 1100 0011 反 13.python的逻辑运算符怎么写，不是位、不是算数运算符？a , b= 10, 20 描述 结果 布尔”与” ：如果 a 为 False，a and b 返回 False，否则它返回 y 的计算值 (a and b) 返回 20 布尔”或”: 如果 a 是非 0，它返回 a 的值，否则它返回 b 的计算值 (a or b) 返回 10 布尔”非” : 如果 a 为 True，返回 False 。如果 a 为 False，它返回 True not(a and b) 返回 False 14.python成员运算符，表示什么意思啊？ 运算符 描述 in 如果在指定的序列中找到值返回 True，否则返回 False。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False 1234567#!/usr/bin/python# -*- coding: UTF-8 -*-a = 10b = 20list = [1, 2, 3, 4, 5 ];if ( a in list ): print \"变量 a 在给定的列表中 list 中\" 15.python身份运算符，用来做什么呢？ 运算符 描述 is x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。 16.python的is 和==有啥区别么？is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。 1234567891011&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = a&gt;&gt;&gt; b is a True&gt;&gt;&gt; b == aTrue&gt;&gt;&gt; b = a[:]&gt;&gt;&gt; b is aFalse&gt;&gt;&gt; b == aTrue 17.python if语句立个flag？1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*- # 例1：if 基本用法flag = Falsename = 'luren'if name == 'python': # 判断变量否为'python' flag = True # 条件成立时设置标志为真 print 'welcome boss' # 并输出欢迎信息else: print name # 条件不成立时输出变量名称 对了，还有elif用来多个条件判断：可以用or、and。 19.python while 循环，这个例子不错，还有flag立，竟然用到else 这个例子用到用了list.pop() 还有flag立 1234567#!/usr/bin/python# -*- coding: UTF-8 -*-var = 1while var == 1 : # 该条件永远为true，循环将无限执行下去 num = raw_input(\"Enter a number :\") print \"You entered: \", numprint \"Good bye!\" 竟然还有else 1234567#!/usr/bin/pythoncount = 0while count &lt; 5: print count, \" is less than 5\" count = count + 1else: print count, \" is not less than 5\" 20.python for字符串、迭代、else、enumerate遍历、质数打印字符串打印 12345678#!/usr/bin/python# -*- coding: UTF-8 -*-for letter in 'Python': # 第一个实例 print '当前字母 :', letterfruits = ['banana', 'apple', 'mango']for fruit in fruits: # 第二个实例 print '当前水果 :', fruitprint \"Good bye!\" 迭代打印 123456#!/usr/bin/python# -*- coding: UTF-8 -*-fruits = ['banana', 'apple', 'mango']for index in range(len(fruits)): print '当前水果 :', fruits[index]print \"Good bye!\" else就是循环执行完之后的操纵。 enumerate：举个例子 12for index, item in enumerate(sequence): process(index, item) 12345678910&gt;&gt;&gt; sequence = [12, 34, 34, 23, 45, 76, 89]&gt;&gt;&gt; for i, j in enumerate(sequence):... print i,j0 121 342 343 234 455 766 89 质数打印： 1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*-# 输出 2 到 100 简的质数prime = []for num in range(2,100): # 迭代 2 到 100 之间的数字 for i in range(2,num): # 根据因子迭代 if num%i == 0: # 确定第一个因子 break # 跳出当前循环 else: # 循环的 else 部分 prime.append(num)print prime 21.python循环嵌套。。。好复杂的样子？思路[未理解]123456789for iterating_var in sequence: for iterating_var in sequence: statements(s) statements(s)while expression: while expression: statement(s) statement(s) 例子：参考20:打印质数： 1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*-i = 2while(i &lt; 100): j = 2 while(j &lt;= (i/j)): if not(i%j): break j = j + 1 if (j &gt; i/j) : print i, \" 是素数\" i = i + 1print \"Good bye!\" 21.python的pass：不做事情。。22.python的数学函数-基本函数 函数 返回值 ( 描述 ) abs(x) 返回数字的绝对值，如abs(-10) 返回 10 ceil(x) 返回数字的上入整数，如math.ceil(4.1) 返回 5 cmp(x, y) 如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1 exp(x) 返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045 fabs(x) 返回数字的绝对值，如math.fabs(-10) 返回10.0 floor(x) 返回数字的下舍整数，如math.floor(4.9)返回 4 log(x) 如math.log(math.e)返回1.0,math.log(100,10)返回2.0 log10(x) 返回以10为基数的x的对数，如math.log10(100)返回 2.0 max(x1, x2,…) 返回给定参数的最大值，参数可以为序列。 min(x1, x2,…) 返回给定参数的最小值，参数可以为序列。 modf(x) 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。 pow(x, y) x**y 运算后的值。 round(x [,n]) 返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。 sqrt(x) 返回数字x的平方根，数字可以为负数，返回类型为实数，如math.sqrt(4)返回 2+0j 23.python随机数函数 函数 描述 choice(seq) 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。 randrange ([start,] stop [,step]) 从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1 random() 随机生成下一个实数，它在[0,1)范围内。 seed([x]) 改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。 shuffle(lst) 将序列的所有元素随机排序 uniform(x, y) 随机生成下一个实数，它在[x,y]范围内。 24.python三角函数 函数 描述 acos(x) 返回x的反余弦弧度值。 asin(x) 返回x的反正弦弧度值。 atan(x) 返回x的反正切弧度值。 atan2(y, x) 返回给定的 X 及 Y 坐标值的反正切值。 cos(x) 返回x的弧度的余弦值。 hypot(x, y) 返回欧几里德范数 sqrt(xx + yy)。 sin(x) 返回的x弧度的正弦值。 tan(x) 返回x弧度的正切值。 degrees(x) 将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0 radians(x) 将角度转换为弧度 25.python字符串的一系列操作。。听多，听过 + * [] [:] in not in % 连接 重复 索引 截取 包涵 不包含 格式化 %格式化：例子： 1print \"My name is %s and weight is %d kg!\" % ('Zara', 21) 三引号：例子：为了避免转移字符繁琐 123456789101112131415 errHTML = '''&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=BackONCLICK=\"window.history.back()\"&gt;&lt;/FORM&gt;&lt;/BODY&gt;&lt;/HTML&gt;'''cursor.execute('''CREATE TABLE users ( login VARCHAR(8), uid INTEGER,prid INTEGER)''') Unicode字符串 12&gt;&gt;&gt; u'Hello World !'u'Hello World !' 基本函数哈 方法 描述 string.capitalize() 把字符串的第一个字符大写 string.count(str, beg=0, end=len(string)) 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 string.decode(encoding=’UTF-8’, errors=’strict’) 以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除 非 errors 指 定 的 是 ‘ignore’ 或 者’replace’ string.encode(encoding=’UTF-8’, errors=’strict’) 以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’ string.endswith(obj, beg=0, end=len(string)) 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False. string.find(str, beg=0, end=len(string)) 检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1 string.index(str, beg=0, end=len(string)) 跟find()方法一样，只不过如果str不在 string中会报一个异常. string.isalpha() 如果 string 至少有一个字符并且所有字符都是字母则返回 True,否则返回 False string.isalnum() 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False string.isdigit() 如果 string 只包含数字则返回 True 否则返回 False. string.islower() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False string.join(seq) 以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 string.lower() 转换 string 中所有大写字符为小写. string.lstrip() 截掉 string 左边的空格 max(str) 返回字符串 str 中最大的字母。 min(str) 返回字符串 str 中最小的字母。 string.replace(str1, str2, num=string.count(str1)) 把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次. string.split(str=””, num=string.count(str)) 以 str 为分隔符切片 string，如果 num有指定值，则仅分隔 num 个子字符串 string.strip([obj]) 在 string 上执行 lstrip()和 rstrip() string.upper() 转换 string 中的小写字母为大写 26.python的list的一系列操作，很多很熟练","categories":[{"name":"python记忆力","slug":"python记忆力","permalink":"https://geekqi.github.io/分类/python记忆力/"}],"tags":[]},{"title":"生财有道一-某所“项目”.","slug":"生财有道一-某所“项目”","date":"2017-05-22T07:41:39.000Z","updated":"2017-05-22T07:41:39.000Z","comments":true,"path":"2017/05/22/生财有道一-某所“项目”/","link":"","permalink":"https://geekqi.github.io/2017/05/22/生财有道一-某所“项目”/","excerpt":"","text":"注：为个人学习总结需要，如有侵权，请您指出。[持续更新， 如有错误，请您指出] 技术／产品／变现 收益：小几十K／几天 团队：3人 项目所用工具／技术：Python 总结： 1.初期：需求沟通：要求：明确需求及基本劳务报酬 2.中期： 任务分配领取 任务阶段监督 任务阶段汇总 3.后期： 任务交付验收 劳务报酬确定 注意： 1.书面材料等洽谈内容一定保留 2.报酬材料等一定落实到具体截止日期","categories":[{"name":"生财有道","slug":"生财有道","permalink":"https://geekqi.github.io/分类/生财有道/"}],"tags":[]},{"title":"最大似然到EM","slug":"最大似然到EM","date":"2017-05-22T03:22:11.000Z","updated":"2017-05-22T03:22:11.000Z","comments":true,"path":"2017/05/22/最大似然到EM/","link":"","permalink":"https://geekqi.github.io/2017/05/22/最大似然到EM/","excerpt":"","text":"注：为个人学习总结需要，如有侵权，请您指出。[持续更新， 如有错误，请您指出] A.最大似然 问题：需要调查学校男生／女生身高分布 要求：抽样后得到的似然函数最大 似然函数：给定输出x时，关于参数θ的似然函数L(θ|x)（在数值上）等于给定参数θ后变量X的概率：L(θ|x)=P(X=x|θ). 求解最值：偏导／梯度 总结：根据结果反推使得该结果出现可能性最大的条件，作为估计值。 步骤： 写出似然函数 对似然函数取对数，并整理 求导数，令为0，得到似然方程 解似然方程，得到参数为所求。 B.EM算法(Expectation Maximization) 问题：同上 解释：要估计A／B两个参数，如果知道A可以得到B，反过来知道B得到A。可以考虑先给A初值，得到B估计值，再从B出发，重新估计A值，直到收敛。 是一种从不完全数据／数据丢失(存在隐含变量)求解概率模型参数的最大似然估计方法。 推导： 假设：样本集中m个独立样本。每个样本i对应的类别z(i)是未知的(相当于聚类)，也即隐含变量。 目标：合适的θ和z让L(θ)最大 转化：Jensen不等式 流程： 初始化分布参数θ 重复以下步骤，直到收敛： E：根据参数初始值／上一次迭代的模型参数来计算隐形变量的后验概率(期望) M：将似然函数最大化以获得最新的参数值 应用：GMM混合高斯模型、聚类、HMM等 参考自： 最大似然到EM","categories":[{"name":"未分类","slug":"未分类","permalink":"https://geekqi.github.io/分类/未分类/"}],"tags":[]},{"title":"机器学习案例分析一：微软网页搜索","slug":"案例分析一：微软网页搜索","date":"2017-05-22T03:16:46.000Z","updated":"2017-05-22T03:16:46.000Z","comments":true,"path":"2017/05/22/案例分析一：微软网页搜索/","link":"","permalink":"https://geekqi.github.io/2017/05/22/案例分析一：微软网页搜索/","excerpt":"","text":"注：为个人学习总结需要，如有侵权，请您指出。[持续更新， 如有错误，请您指出] A.提高网页搜索结果的相关性 基本思想：快速实现的能力：快速处理 实现方法：Boosted Decision Trees 方法可解决问题： 排序：置顶最相关网页 分类：垃圾邮件分类 回归分析：房价预估 研究／产品周期开发案例： 挑战：1.提出对的问题， 2.很好的验证 解决方法：从实际问题出发 发出请求： 高效扫描索引中所有文件，快速过滤器过滤。将候选文档数减少到可控规模 对每个候选文档，生成几千个特征表示与查询内容的相关度 比如把特征列表映射到一个对查询相关的文档进行编码的分数 结合过滤处理，再排序 总结：整体过程良性循环，工程和产品的需求推动研究的进展，而研究为产品开发提供了新的机遇 参考自： 微软搜索案例","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://geekqi.github.io/分类/机器学习/"}],"tags":[]},{"title":"数据挖掘二.1：分类模型汇总","slug":"数据挖掘二.1分类模型汇总","date":"2017-05-21T14:40:23.000Z","updated":"2017-05-21T14:40:23.000Z","comments":true,"path":"2017/05/21/数据挖掘二.1分类模型汇总/","link":"","permalink":"https://geekqi.github.io/2017/05/21/数据挖掘二.1分类模型汇总/","excerpt":"","text":"注：为个人学习总结需要，如有侵权，请您指出。[持续更新， 如有错误，请您指出] 具体问题的分类参见数据挖掘二：问题分类汇总 A.LogisticRegression模型简介逻辑回归 适用情况：预测是否点击特定商品／判断用户性别／预测用户是否会购买给定的品类／判断评论是正面还是负面 常用算法：逻辑回归／支持向量机「都属于有监督学习」 注意事项：模型效果往往与所用特征紧密相关 1.模型 sigmoid函数 决策函数 目的：机器学习模型就是将决策函数限定在某一组条件下， 这组条件决定了模型的假设空间。 方式：y* = 1, if P(y=1| x) &gt; 0.5。如果对正例准确性要求高，阈值可大一些；对正例召回率要求高， 阈值可小 参数求解 目的：模型的数学形式确定了，剩下就是求参数 求解方式：最大似然估计／损失函数(0-1/log/hinge) 求解方式：梯度下降／共轭梯度下降／牛顿法／LBFGS等 原因：保证损失函数是减小的／LR的损失函数是凸函数，可保证局部最优也是全局最优。 正则化 目的：控制模型复杂度， 防止过拟合 方法：在优化目标中加入正则项， 通过惩罚过大参数防止过拟合 L1:使参数变为0，能产生稀疏解[由于数据维度高，使用较为广泛]／L2 2.延伸 生成模型和判别模型 LR：判别模型：直接对条件概率P(y|x)建模， 不关心背后数据分布P(y|x) 高斯贝叶斯(Gaussian Naive Bayes):生成模型：先对数据的联合分布建模， 再通过贝叶斯公式计算样本属于各个类别的后验概率 多分类(softmax) 解释：y 不是在0/1中取值，而是在K个类别中取值 处理方法一：对每个类别训练一个二元分类器(One-vs-All)：当K个类别不是互斥的时候 ，比如用户会购买哪种品类，可用此方法。 处理方法二：Softmax回归：当K个类别互斥， 即y = i 不能取其他的值， 比如用户年龄段。：是直接对LR在多分类的推广(Multinomial Logistic Regression)。 求解方法：梯度下降／其他高阶方法 3.应用：美团如何用LR解决实际问题 情况：预测未来是否购买：1/0。 选用特征如下 其中：特征跨度30天，标签2天。训练数据7千万量级。 处理过程： 品类聚合：人工把相似的小品类聚合起来：18个较为典型的品类集合 构建训练集：如果用户给定时间购买某一品类集合， 作为正例 LR训练：有了训练集，用Spark的LR算法对每个品类训练一个二分类模型，迭代100次40分钟。每个模型2分钟。测试集AUC也0.8以上。 训练结果：训练好模型会保留下来， 用于预测各个品类上购买概率。 预测结果会用于推荐等场景。 实际转化：由于不同品类间正负例分布不同。尝试不同采样方法。最终目标：提高下单率等线上指标。经过一些参数调优，品类偏好特征为推荐和排序带来超过1%的下单率提升 心得：由于LR模型简单高效， 易于实现，可为后续模型优化提供不错baseline， 在排序等服务中也使用了LR模型。 适用情况：微博用户情感分析、用户对理财产品偏好性分析。 比如：通过微博分析用户情感属于喜怒哀乐等哪类， 将理财产品的用户群体分为偏好型／温和型／厌恶型 判断方法：标签y有多维：每一维代表一个标签， 取值只有两个， 比如0-1。 或者， y只有一维， 取值有多个。 4.总结 LR的数学模型和求解相对简洁。通过对特征离散化和其他映射，逻辑回归可处理非线性问题， 是强大分类器。 在实际应用中， 拿到许多低层次的特征时， 可考虑LR解决问题 参考自： 美团技术团队LR模型简介","categories":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://geekqi.github.io/分类/数据挖掘/"}],"tags":[]},{"title":"数据挖掘四：特征处理方法汇总","slug":"数据挖掘四-特征处理方法汇总","date":"2017-05-21T14:12:14.000Z","updated":"2017-05-21T14:12:14.000Z","comments":true,"path":"2017/05/21/数据挖掘四-特征处理方法汇总/","link":"","permalink":"https://geekqi.github.io/2017/05/21/数据挖掘四-特征处理方法汇总/","excerpt":"","text":"注：为个人学习总结需要，如有侵权，请您指出。[持续更新， 如有错误，请您指出] 1.类别变量处理 处理原则：先标签化， 再二值化编码。 处理目的：标签化：将字段的原始值(字符串／不连续数字等)转化成连续的整数值， 再将整数值二值化编码。 如果原始值是整数， 则直接二值化即可。 处理情况：不同颜色， 不同国家 处理方法：scikit-learn的LabelBinarizer()和OneHotEncoder()。pandas的DataFrameMapper，get_dummies()。DataFrameMapper结合 sklearn 的Transformer类，来进行列变换。等 2.数值变量处理 处理原则：只需正规化和标准化 处理目的：最好也进行离散化 处理情况：不同尺寸， 不同数值大小 处理方法：pandas：map()。 scikit-learn的Normalizer和StandardScaler 3.文本变量处理 处理原则：词频， n-gram，TF-IDF[减小停用词权重] 处理目的： 处理情况：用户评论／新闻摘要／视频弹幕等 处理方法：scikit-learn的corpus和CountVectorizer和CountVectorizer(ngram_range=(1, 2))和TfidfVectorizer 4.缺失值处理 处理原则： 处理目的： 处理方法：填充／丢弃／看作新类别 5.长尾特征处理常见于数值类型的变量 处理原则： 处理目的：将变量的分布相对均衡 处理方法：log(x+1)处理 处理方法比较： 参考自： 举例 举例 举例","categories":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://geekqi.github.io/分类/数据挖掘/"}],"tags":[]},{"title":"主要目标判断","slug":"主要目标判断","date":"2017-05-21T09:07:31.000Z","updated":"2017-05-21T09:07:31.000Z","comments":true,"path":"2017/05/21/主要目标判断/","link":"","permalink":"https://geekqi.github.io/2017/05/21/主要目标判断/","excerpt":"","text":"注：为个人学习总结需要，如有侵权，请您指出。[持续更新， 如有错误，请您指出] 1.刷题 目的分析：基础知识的掌握牢固， 「 基础熟练决定你的灵活性！」 解决办法：大量做题，「 不比别人熟练，必败」 可能结果： 可能方式：纽克、柒越 2.简历 目的分析：让人接受你的努力， 「 被认可，被膜拜，这是主流！」 解决办法： 可能结果： 可能方式： 时间节点：6月底 3.经验 目的分析：系统性质的项目过程， 「 灵活的经验才能被主流朝拜！」 解决办法：实战项目、开源项目， 「 片段化不系统，机会抓不住」 可能结果： 可能方式：豪洞悉、艾科科、工种薅","categories":[{"name":"主要目标判断","slug":"主要目标判断","permalink":"https://geekqi.github.io/分类/主要目标判断/"}],"tags":[]},{"title":"数据挖掘二：问题分类汇总","slug":"数据挖掘二-问题分类汇总","date":"2017-05-21T08:23:51.000Z","updated":"2017-05-21T08:23:51.000Z","comments":true,"path":"2017/05/21/数据挖掘二-问题分类汇总/","link":"","permalink":"https://geekqi.github.io/2017/05/21/数据挖掘二-问题分类汇总/","excerpt":"","text":"注：为个人学习总结需要，如有侵权，请您指出。[持续更新， 如有错误，请您指出] A.分类问题：1.二分类问题 适用情况：工业界：广告点击率预估、推荐系统购买行为预测。比如：预测广告是否会被用户点击， 用户是否会购买某种商品 判断方法：标签y只有一维：取值只有两个， 比如0-1。 2.多分类问题 适用情况：微博用户情感分析、用户对理财产品偏好性分析。 比如：通过微博分析用户情感属于喜怒哀乐等哪类， 将理财产品的用户群体分为偏好型／温和型／厌恶型 判断方法：标签y有多维：每一维代表一个标签， 取值只有两个， 比如0-1。 或者， y只有一维， 取值有多个。 3.多标签问题 适用情况：音乐的标签划分。 比如：标签集合：{独奏，协奏，浪漫主义，印象主义}，「月光」属于{独奏，印象主义}，「保卫黄河」属于{协奏}。 判断方法：标签y有多维， 与多分类不同在于： 本本可以同时属于多个标签。 B.回归问题1.单回归问题 适用情况：比如：股价预测 判断方法：y只有一维， 取值为连续值。 2.多回归问题 适用情况：比如：天气预报：气温、湿度、降雨量 判断方法：y有多维， 取值为连续值 参考自： 举例 举例","categories":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://geekqi.github.io/分类/数据挖掘/"}],"tags":[]},{"title":"数据挖掘一：误区汇总","slug":"数据挖掘一-误区汇总","date":"2017-05-21T08:23:45.000Z","updated":"2017-05-21T08:23:45.000Z","comments":true,"path":"2017/05/21/数据挖掘一-误区汇总/","link":"","permalink":"https://geekqi.github.io/2017/05/21/数据挖掘一-误区汇总/","excerpt":"","text":"注：为个人学习总结需要，如有侵权，请您指出。[持续更新， 如有错误，请您指出] 1.过于注重训练 误区分析：没有实战训练，封闭式训练 。只有样本外的模型评分结果才有用！ 解决办法：重抽样：bootstrap、cross-validation、jackknife、leave-one-out…等等。 2.只依赖一种技术 误区分析：没有对比就没有好坏， 辩证法的思想 解决办法：至少和传统：线性回归／线性判别分析做个比较。 使用一系列好的工具和方法。 每种带来最多5%～10%的改进。 3.关注错的目标 误区分析：分类算法用分类精度衡量， 但实际几乎不看，因为不是关注的目标 解决办法：项目目标[比如欺诈电话分析， 重点不是分类，而是如何描述正常的特征，然后据此发现异常]／模型目标[计算机如何改善业务， 不仅仅模型计算精度] 4.过度依赖数据 误区分析：如果数据+工具可以解决，要人干什么。[兼听则明， 偏听则暗] 解决办法：对数据处理结果分析 5.抽样有问题 误区分析：没有保证抽样的随机性， 人为提高原始数据的权重 解决办法：注意随机性，以及模型的现实可靠性。 处理方法：scikit-learn的LabelBinarizer()和OneHotEncoder()。pandas的get_dummies()。等","categories":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://geekqi.github.io/分类/数据挖掘/"}],"tags":[]},{"title":"数据挖掘三：数据集划分","slug":"数据挖掘三-数据集划分","date":"2017-05-21T08:23:35.000Z","updated":"2017-05-21T08:23:35.000Z","comments":true,"path":"2017/05/21/数据挖掘三-数据集划分/","link":"","permalink":"https://geekqi.github.io/2017/05/21/数据挖掘三-数据集划分/","excerpt":"","text":"注：为个人学习总结需要，如有侵权，请您指出。[持续更新， 如有错误，请您指出] 数据集划分：训练集／验证集。 或者还需要划分出测试集 目的：先用训练集／验证集的交叉验证来寻找模型的最优超参数， 模型调优完毕后， 最终用测试集来评估模型的最终效果。 A.分类问题： 划分原则：根据标签划分数据集。比如：每种标签采样多少， 保证训练集和验证集的样本标签分布接近。 划分方法：随机采样／分层采样[K折交叉验证]。 可以根据实际业务问题选择合适的采样方式 B.回归问题 划分原则：不逊在分类中标签分布不均匀情况。 划分方法：K折交叉验证 交叉验证 目的：寻找最优的超参数 方法：sklearn 中的KFold ，train_test_split， metric.score, GridSearchCV等 参考自： 举例","categories":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://geekqi.github.io/分类/数据挖掘/"}],"tags":[]},{"title":"Hello Change, YangQi","slug":"hello-world","date":"2017-05-19T09:50:51.000Z","updated":"2017-05-19T09:50:51.000Z","comments":true,"path":"2017/05/19/hello-world/","link":"","permalink":"https://geekqi.github.io/2017/05/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Blog","slug":"Blog","permalink":"https://geekqi.github.io/分类/Blog/"}],"tags":[]}]}